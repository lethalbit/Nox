# N5305A Notes

The following notes discuss the process of N5305A module boot up, configuration, programming, and analyses connection as seen from over the network.

## N5305A Initial Configuration

It seems like the N5305A, and all other modules for the N5540A want to have an DHCP daemon on `10.0.0.1/8` with `BOOTP` support. They also expect an FTP daemon on this same port to serve the files for module initialization and gateware.

There are also some services running on some TCP and UDP ports on the controller which look to be orchestration and control.

## N5305A boot

`TODO`

## N5305A Diagnostics

`TODO`

## N5305A Gateware Initialization

`TODO`

## N5305A Analysis

`TODO`


## Protocol Notes

The following notes cover the TCP protocol that is seen on port `1029` on the analyzer.

### Protocol Stack

From what we can tell, and it's unsure if this is for all modules that are used in the N2X system or just this N5305A and it's software, there is another custom transport layer implemented on top of TCP due to the fact some of the packets can be bigger than the MTU size, most notably the filter and trigger setup packets for the modules.

The network framing stack-up looks like this:

```
 0               1               2               3
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                       ETHERNET HEADER                         |
+                          (14 bytes)                           +
|                                                               |
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
+                                                               +
|                           IP4 Header                          |
+                           (20 bytes)                          +
|                                                               |
+                                                               +
|                                                               |
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                                                               |
+                                                               +
|                           TCP Header                          |
+                           (20 bytes)                          +
|                                                               |
+                                                               +
|                                                               |
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |     N2X TRANSPORT HEADER      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     N2X TRANSPORT HEADER      |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                             PAYLOAD                           |
+                        (up to 1460 bytes)                     +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

The transport header consists of two `uint16_t` MSB fields as described below:

```
 0               1               2               3
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             FLAGS             |         PAYLOAD LENGTH        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

`FLAGS` is a 16-bit flags field but we've been only able to figure out what one of the bits does at this point in time. The bits are as follows.
 * Bit 0: ?
 * Bit 1: ?
 * Bit 2: ?
 * Bit 3: ?
 * Bit 4: ?
 * Bit 5: ?
 * Bit 6: ?
 * Bit 7: ?
 * Bit 8: ?
 * Bit 9: ?
 * Bit A: ?
 * Bit B: ?
 * Bit C: ?
 * Bit D: ?
 * Bit E: ?
 * Bit F: End of transaction - No more packets in the same transaction follow this

`PAYLOAD LENGTH` looks to be the length of the whole transaction payload minus 4 bytes. This means that a transaction can span more than one packet, in that case the Ethernet, IP, and TCP headers are still applied, but the N2X Transport header is not and the remainder is just filled with payload data.

The maximum value we've seen for `PAYLOAD LENGTH` is `0x0FFC` or 4092 in decimal, four short of a full 4096 byte page. These transactions fill 3 whole packets, 2 with a total frame data size of 1460 and a single 1176 byte packet, for a total of 4096 bytes transfered with 4092 of those bytes being payload data and the first 4 being the transport header.

This has been seen to transport large 64KiB configuration packets to the analyzer over many many spans of 4KiB chunks each consisting of three packets, as well as just standard packets.

**NOTE:** When transferring large chunks of data, the last packet to make up a 4KiB block has the TCP `PUSH` flag set to flush the buffer. It is unknown if this is done manually or automatically as each block of three packets is about the size of a normal memory page on amd64.

### Payload

The `PAYLOAD` data depends on what the transaction is. There are the payloads with raw blocks of data, and then there are payload packets with their own header as described below.

```
 0               1               2               3
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             FLAGS?            |       TRANSPORT COOKIE        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                             DATA                              |
+                       (up to 1456 bytes)                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

The first field is possibly another flags field, but that's unconfirmed at the moment. The second field, is a transport cookie that is used to correlate packets between the analyzer and the host machine. It always starts from `0` and increments by one for each message to the analyzer, the analyzers response contains the same cookie. As far as we know, being consistent with the N2X transport header both values are in MSB.

**NOTE:** With the analyzer, it also responds with packets that have a transport cookie with the value of `0` every so often, these are thought to not be related to any active transaction but contain statistical data or sniffer data back from the analyzer to the host asynchronously over the same TCP connection.

### Payload Data

**NOTE:** The information described here only contains information about packets sent to the analyzer, we have not been able to divine any information returned from the analyzer at this point.

The `DATA` in these packets can be anything as far as we currently know, but there are some we've noticed but been unable to decode. The data also seems to be padded with `0x00` up to the nearest 4 byte boundary.

In packets that have a `ln` message as the first of the message strings, it appears that's always followed by two additional message strings.

In packets that have a `rm` message string, it appears there are never any additional message strings.

There are packets which contain a series of null padded length-prefixed strings. The length prefix is a 4-byte MSB value, followed directly by the string. The string is then padded with `0x00` up to the next 4-byte boundary.

If `len` is the the 4-byte value which is the length of the string, the padding is calculate like follows: `(len + ((4 - (len % 4)) & 3)) + 4`, that should return the number of needed padding bytes.

The following are some common strings we've noticed:
 * Length: `0x02`; Message: `rm` - remove an object?
 * Length: `0x02`; Message: `ln` - symlink an object?
 * Length: `0x17`; Message: `IDevAnalyzerControl1029`
 * Length: `0x14`; Message: `IDevAnalyzerData1029`
 * Length: `0x16`; Message: `IDevSegmentManager1029`
 * Length: `0x13`; Message: `IDevPaSequencer1029`
 * Length: `0x11`; Message: `IDevHeartbeat1029`
 * Length: `0x13`; Message: `AnalyzerStateChange`
 * Length: `0x22`; Message: `MultiframeCorrelationCounterChange`
 * Length: `0x16`; Message: `SWPackageCheckObserver`
 * Length: `0x0A`; Message: `SourceInfo`
 * Length: `0x0E`; Message: `TransactionMap`
 * Length: `0x13`; Message: `Record10BitResponse`
 * Length: `0x14`; Message: `RecordVectorResponse`
 * Length: `0x0C`; Message: `FileSaveInfo`
 * Length: `0x0E`; Message: `RecordResponse`
 * Length: `0x0A`; Message: `RecordData`
 * Length: `0x14`; Message: `CancelRecordResponse`
 * Length: `0x0D`; Message: `GetSourceInfo`
 * Length: `0x12`; Message: `setSequencerMemory`
 * Length: `0x09`; Message:	`Heartbeat`

The remainder of the messages and control strings will be cataloged and noted later on.


In many cases there is trailing data after the last message, but we've not been able to figure out what that is quite yet.

With `IDevAnalyzerData1029` the `ln` message is sometimes preceding it, but not always, where as it looks like `IDevAnalyzerControl1029` and `IDevSegmentManager1029` always have the `ln` message prior to the command itself. Where as `IDevPaSequencer1029` never seems to have an `ln` message before it.


## PCAP Notes

### N5305A-pa-session-config.pcapng

Packet #25699 + #25701 + #25703 matches the notes for the session start capture below

### N5305A-pa-session-start.pcapng

Packet #25113 + 25115 + 25117:

 * #25113:
   * Odd length value (0x0FFC)
   * Preceeded by PSH'd packet to the analyser
   * Very specific frame length of 1460
 * #25115:
   * No N5305A headers (just data)
   * Also 1460 bytes
 * #25117:
   * No N5305A headers (just data)
   * 1176 bytes
   * PSH'd packet
 * 0xFFC in decimal is 4092
 * 1460 + 1460 + 1176 - 4 = 4092
 * custom frag system based on 1460 byte packets followed by trailing packet with remainder of the data and TCP PSH set

Huge data packets exactly fit 1 page of RAM (4096 bytes) once stripped of TCP framing, but including N5305A header data
End of huge packet stream has one sane-sized packet, flags 0x8000 (end of transaction set) with TCP PSH set

